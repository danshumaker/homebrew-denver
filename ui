#!/usr/bin/env bash
# Author: Dan Shumaker
# Date: 2025-12-31
#
# Denver (Developer Environment Manager) Installer/Uninstaller
#
# vim: ft=bash:

# Set script name based on file name.
_whoami="${0##*/}"
_whereami=$(dirname "$0")

# HEREDOCS + READ HELP FUNCTION
function help() {
  read -r -d '' HELP <<-START
    $_whoami  Installer for Developer Environment Manager (Denver)

    -h help        (print help)
    -v             (turn on verbose debugging)
    -u|--uninstall (uninstall everything or specified asset)
    --priv         (make repo private)
    --pub          (make repo public)
    -d|--dry-run   (dry run - do nothing but echo commands)
    -p|--prompt    (prompt before each command and wait for input)
    --clean        (remove all of denver)

    ASSETS
    --xcode        (install xcode only)
    --brew         (install homebrew)
    --denver       (install denver)
    --bundle       (bundle install)
    --dots         (dotfiles backup and linking)
    --shell        (change shell)
    --rust         (install rust)

    Usage:

       $_whoami

       Without any arguments everything is installed without a prompt and with colored output.

    Requirements/Dependencies:
    - The repo is unlocked and public
    - curl
    - 1password (op authenticated)
    - gh (github tool authenticated)

    ✓ Kitty shell usage - setup verified
    ✓ Fonts Installed - (used nerd-font forumlas instead - possible powerline fonts install git clone https://github.com/powerline/fonts

    TODO:
     - Store Github token in 1pass
     - Convert to using GITHUB_TOKEN https://dev.to/jhot/homebrew-and-private-github-repositories-1dfh?utm_source=chatgpt.com"
     - Consolidate ui into install and uninstall into ui.
     - Configure 1Pass-cli .config/op/config
     - ^S^I in Tmux to picup installed plugins
     - .config/gh github authentication
     - configure .ssh do ssh-keygen but also convert to 1Pass-OP
     - Ensure docksal, colima, and terminus work
     - Ensure node and hugo work in resume theme
     - Ensure shutrail standsup

START

  echo ""
  echo "$HELP"
  echo ""
}

# ---------------- IO Colors ----------------
if test -t 1 && command -v tput >/dev/null 2>&1; then
  BLUE="$(tput setaf 4)"
  YELLOW="$(tput setaf 3)"
  RED="$(tput setaf 1)"
  GREEN="$(tput setaf 2)"
  RESET="$(tput sgr0)"
else
  BLUE=""
  YELLOW=""
  RED=""
  GREEN=""
  RESET=""
fi

# ---------------------- IO -------------------
info() { printf "%s[INFO]%s %s\n" "$BLUE" "$RESET" "$*"; }
warn() { printf "%s[WARN]%s %s\n" "$YELLOW" "$RESET" "$*"; }
error() {
  printf "%s[ERROR]%s %s\n" "$RED" "$RESET" "$*"
  exit 1
}
ok() { printf "%s[SUCCESS]%s %s\n" "$GREEN" "$RESET" "$*"; }

run() {
  if (($DRY)); then
    echo "DRYRUN: $*"
  else
    if (($PROMPT)); then
      ring_bell
      echo "::RUN:: $@   ???"
      wait_for_user
      eval "$@"
    else
      eval "$@"
    fi
  fi
}

getc() {
  local save_state
  save_state="$(/bin/stty -g)"
  /bin/stty raw -echo
  IFS='' read -r -n 1 -d '' "$@"
  /bin/stty "${save_state}"
}

ring_bell() {
  # Use the shell's audible bell.
  if [[ -t 1 ]]; then
    printf "\a"
  fi
}

wait_for_user() {
  local c
  warn "Press RETURN/ENTER to continue or any other key to abort:"
  getc c
  # we test for \r and \n because some stuff does \r instead
  if ! [[ "${c}" == $'\r' || "${c}" == $'\n' ]]; then
    exit 1
  fi
}

# ---------------------- repo -----------------
hide() {
  gh repo edit --visibility private --accept-visibility-change-consequences
}

unhide() {
  gh repo edit --visibility public --accept-visibility-change-consequences

}

declare -i PROMPT=0
declare -i DRY=0
declare -i UNINSTALL=0

# ---------------- Detect OS -------------------
OS="$(uname -s)"
case "$OS" in
Darwin) PLATFORM="macos" ;;
Linux) PLATFORM="linux" ;;
*) error "Unsupported OS: $OS" ;;
esac
info "Platform: $PLATFORM"

# Capture Arguements
argc=$#   # total args
argv=($@) # array of args

# Process CLI Settings
# - Go through the boolean only args and remove them so that They
#   do not confuse the command line options processing below.
for ((j = 0; j < argc; j++)); do
  case ${argv[j]} in
  -p | --prompt)
    PROMPT=1
    argv=("${argv[@]:0:$j}" "${argv[@]:($j + 1)}")
    argc=$(($argc - 1)) # two subtracted
    # Integer variable decrement - only decrement j because argc and argv
    # have been adjusted
    ((j--))
    ;;
  -d | --dry-run)
    DRY=1
    argv=("${argv[@]:0:$j}" "${argv[@]:($j + 1)}")
    argc=$(($argc - 1))
    ((j--))
    ;;
  -v)
    # Boolean Arguement
    argv=("${argv[@]:0:$j}" "${argv[@]:($j + 1)}")

    # Remove the arguement from the list of args
    argc=$(($argc - 1)) # decrement by 1
    ((j--))
    set -v
    set -x
    ;;
  -u | --uninstall)
    UNINSTALL=1
    argv=("${argv[@]:0:$j}" "${argv[@]:($j + 1)}")
    argc=$(($argc - 1)) # two subtracted
    # Integer variable decrement - only decrement j because argc and argv
    # have been adjusted
    ((j--))
    ;;
  esac
done

xcode() {
  if [[ "$PLATFORM" == "macos" ]]; then
    if ! xcode-select -p >/dev/null 2>&1; then
      if (($UNINSTALL)); then
        ok "Xcode is not installed"
      else
        info "Installing Xcode Command Line Tools"
        run "xcode-select --install"
      fi
    else
      if (($UNINSTALL)); then
        run "sudo rm -rf /Library/Developer/CommandLineTools"
        ok "Xcode Command Line tools removed"
      else
        info "Xcode Command Line Tools are already installed."
      fi
    fi
  fi
}

# ----------------- Change Zsh to Bash default shell -------
shell() {
  info "Auditing shell configuration..."

  if [[ -z "${SHELL:-}" ]]; then
    error "\$SHELL is not set."
  fi

  if [[ ! -x "$SHELL" ]]; then
    error "\$SHELL points to a non-executable: $SHELL"
  fi

  if (($UNINSTALL)); then
    chsh -s "/bin/zsh"
  else
    if ! grep -qx "$SHELL" /etc/shells; then
      warn "\$SHELL ($SHELL) is not listed in /etc/shells"
    fi

    if command -v brew >/dev/null 2>&1; then

      info "Enforcing Homebrew bash as login shell..."

      BREW_BASH="$(brew --prefix)/bin/bash"

      if ! grep -qx "$BREW_BASH" /etc/shells; then
        info "Registering Homebrew bash in /etc/shells"
        echo "$BREW_BASH" | sudo tee -a /etc/shells >/dev/null
      fi

      if [[ "$SHELL" != "$BREW_BASH" ]]; then
        info "Changing login shell to $BREW_BASH"
        chsh -s "$BREW_BASH"
        ok "Login shell updated. Log out/in required."
      else
        ok "Homebrew bash already set as login shell"
      fi
    fi
  fi

}

# ---------------- Homebrew --------------
homebrew() {
  if ! command -v brew >/dev/null 2>&1; then
    if (($UNINSTALL)); then
      ok "Homebrew is not installed"
    else
      info "Installing Homebrew..."
      run '/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"'
    fi
  else
    if (($UNINSTALL)); then
      info "Uninstalling Homebrew"
      run '/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)"'
      exit 0
    else
      info "Homebrew already installed."
    fi
  fi

  # Load brew shellenv
  BREW_PREFIX="$(brew --prefix)"
  run 'eval "$(${BREW_PREFIX}/bin/brew shellenv)"'
}

payload() {
  command -v brew >/dev/null 2>&1 || error "Homebrew not installed."
  # ---------------- Verify Installation Success ----------------
  DENVER_PREFIX="$(brew --prefix denver || true)"
  PAYLOAD_DIR="$DENVER_PREFIX/share/denver"
  BREWFILE=$PAYLOAD_DIR/Brewfile
  DOTS=$PAYLOAD_DIR/dotfiles
  BACKUP_DIR="$HOME/.old_dots/backup_$(date +%Y%m%d_%H%M%S)"

  if [[ ! -d "$DENVER_PREFIX" ]]; then
    error "Denver prefix not found at: $DENVER_PREFIX"
  fi

  if [[ ! -d "$PAYLOAD_DIR" ]]; then
    error "Denver payload directory missing: $PAYLOAD_DIR"
  fi

  info "Denver payload detected at: $PAYLOAD_DIR"

  # ---------------- Verify Brewfile Exists ----------------

  if [[ ! -f "$BREWFILE" ]]; then
    error "Brewfile missing at: $BREWFILE"
  fi

}

# ---------------- Tap + Install formula ----------
denver() {
  if brew list --formula denver >/dev/null 2>&1; then
    if (($UNINSTALL)); then
      brew uninstall --zap --force denver 2>/dev/null || brew uninstall --force denver
      rm -rf "$(brew --cellar)/denver"
      rm -f "$(brew --prefix)/opt/denver"
      brew cleanup -s denver || true
      rm -f "$(brew --cache)"/denver--* 2>/dev/null || true
    else
      ok "Denver Installed"
    fi
  else
    if (($UNINSTALL)); then
      ok "denver is NOT installed"
    else
      run "brew tap danshumaker/denver"
      run "brew install denver"
      payload
    fi
  fi
}

# ---------------- Brew bundle --------------------
bundle() {
  if (($UNINSTALL)); then
    info "Uninstalling Homebrew formulas from Denver Brewfile..."
    payload

    if [[ -f "$BREWFILE" ]]; then
      brew bundle list --file "$BREWFILE" --formula |
        xargs brew uninstall --ignore-dependencies || true

      brew bundle list --file "$BREWFILE" --cask |
        xargs brew uninstall --cask --force || true

      brew autoremove
      brew cleanup --prune=all
    else
      error "Denver Brewfile not found"
    fi
  else
    logfile="/tmp/brew-bundle.log"
    info "Running brew bundle using ${BREWFILE}…"
    set +e # we will handle errors manually
    brew bundle --upgrade --file="${BREWFILE}" 2>&1 | tee "${logfile}"
    status=${PIPESTATUS[0]}
    set -e
    if [[ $status -ne 0 ]]; then
      error "brew bundle failed (exit code ${status}). See ${logfile}"
    fi
    ok "Brew bundle finished successfully"
  fi

}

# ---------------- Dotfile backup and Linking -------
dotfiles() {
  payload
  if (($UNINSTALL)); then
    if command -v rcdn >/dev/null 2>&1; then
      info "Removing Dotfile RCM symlinks..."
      cd "$HOME"
      run "rcdn -v -d \"$DOTS\""
    else
      warn "rcdn not found — cannot remove rcup symlinks."
    fi
    if [[ -d "$HOME/.old_dots" ]]; then
      LAST_BACKUP="$(ls -1dt "$HOME/.old_dots"/* 2>/dev/null | head -1)"
      if [[ -d "$LAST_BACKUP" ]]; then
        info "Restoring backup from $LAST_BACKUP"
        run "cp -v -R \"$LAST_BACKUP/.\" \"$HOME/\""
      else
        warn "No backups found inside ~/.old_dots"
      fi
    else
      warn "~/.old_dots does not exist; no backups to restore."
    fi
  else
    # ---------------- Backup dotfiles ----------------
    run "mkdir -p \"$BACKUP_DIR\""

    info "Backing up existing dotfiles... to $BACKUP_DIR"

    files=$(find "$DOTS" -type f -depth 1)
    for f in ${files[@]}; do
      rootFName=$HOME/.$(basename $f)
      if [[ -e "$rootFName" ]]; then
        if [[ -L "$rootFName" ]]; then
          # If it's a link then do NOT back it up but remove it so new links can be made
          run "rm -v \"$rootFName\""
        else
          run "mv -v \"$rootFName\" \"$BACKUP_DIR/\""
        fi
      fi
    done

    info "Running rcup..."
    cd $HOME
    run "ln -s \"$DOTS\"/rcrc $HOME/.rcrc"
    run "rcup -v -d \"$DOTS\""
    if [[ ! -L $HOME/.bash_profile ]]; then
      error "RCM up did not link dotfiles."
    else
      ok "Dotfiles installed"
      lsrc -d "$DOTS"
    fi
  fi
}

# ---------------- Rust --------------------
rust() {
  if ! command -v cargo >/dev/null 2>&1; then
    if (($UNINSTALL)); then
      info "Rust/Cargo Uninstalled"
    else
      info "Installing Rust/Cargo toolchain..."
      run 'curl --proto "=https" --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y'
    fi
  else
    if (($UNINSTALL)); then
      if command -v rustup >/dev/null 2>&1; then
        info "Removing Rust toolchain..."
        run "rustup self uninstall -y"
      fi
    else
      info "Rust already installed."
    fi
  fi
}

cd $HOME
# Process Commands
for ((j = 0; j < argc; j++)); do
  case ${argv[j]} in
  -h)
    # Function call
    help
    exit
    ;;
  --xcode)
    xcode
    exit
    ;;
  --brew)
    homebrew
    exit
    ;;
  --denver)
    denver
    exit
    ;;
  --bundle)
    bundle
    exit
    ;;
  --shell)
    shell
    exit
    ;;
  --rust)
    rust
    exit
    ;;
  --dots)
    dotfiles
    exit
    ;;
  --priv)
    hide
    ;;
  --pub)
    unhide
    ;;
  *)
    pp "%s" RED "Invalid Option ${argv[j]}"
    help
    exit
    ;;
  esac
done

if (($UNINSTALL)); then
  rust
  shell
  dotfiles
  bundle
  denver
  homebrew
  xcode
else
  # INSTALL DEFAULT
  xcode
  homebrew
  denver
  bundle
  dotfiles
  shell
  rust
  ok "Denver installation complete."
fi
