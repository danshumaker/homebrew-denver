#!/usr/bin/env bash
# Author: Dan Shumaker
# Date: 2025-12-31
#
# Denver (Developer Environment Manager) Installer/Uninstaller
#
# vim: ft=bash:

# ----------- Initialization ---------------
# Set script name based on file name.
_whoami="${0##*/}"
_whereami=$(dirname "$0")
declare -i PROMPT=0
declare -i DRY=0
declare -i UNINSTALL=0
OS="$(uname -s)"
# ---------------- IO Colors ----------------
if test -t 1 && command -v tput >/dev/null 2>&1; then
  BLUE="$(tput setaf 4)"
  YELLOW="$(tput setaf 3)"
  RED="$(tput setaf 1)"
  GREEN="$(tput setaf 2)"
  RESET="$(tput sgr0)"
else
  BLUE=""
  YELLOW=""
  RED=""
  GREEN=""
  RESET=""
fi

# ---------------------- Administration Functions -------------------
# HEREDOCS + READ HELP FUNCTION
function help() {
  read -r -d '' HELP <<-START
    $_whoami  Installer for Developer Environment Manager (Denver)

    -h|--help        (print help)
    -v               (turn on verbose debugging)
    -u|--uninstall   (uninstall everything or specified asset)
    --priv|--private (make repo private)
    --pub|--public   (make repo public)
    -d|--dry-run     (dry run - do nothing but echo commands)
    -p|--prompt      (prompt before each command and wait for input)
    --ub             (update brewfile)
    --bump           (bump the repo version)

    Install Assets
    --xcode          (install xcode only)
    --brew           (install homebrew)
    --denver         (install denver)
    --bundle         (bundle install)
    --dots           (dotfiles backup and linking)
    --shell          (change shell)
    --rust           (install rust)

    Usage:

       $_whoami

       Without any arguments everything is installed without a prompt and with colored output.

    Requirements/Dependencies:
    - The repo is unlocked and public
    - curl

    ✓ Kitty shell usage - setup verified
    ✓ Fonts Installed - (used nerd-font forumlas instead - possible powerline fonts install git clone https://github.com/powerline/fonts

    TODO:
     - Store Github token in 1pass
        - 1password (op authenticated)
        - gh (github tool authenticated)
     - Convert to using GITHUB_TOKEN https://dev.to/jhot/homebrew-and-private-github-repositories-1dfh?utm_source=chatgpt.com"
     - Consolidate ui into install and uninstall into ui.
     - Configure 1Pass-cli .config/op/config
     - ^S^I in Tmux to picup installed plugins
     - .config/gh github authentication
     - configure .ssh do ssh-keygen but also convert to 1Pass-OP
     - Ensure docksal, colima, and terminus work
     - Ensure node and hugo work in resume theme
     - Ensure shutrail standsup

START

  echo ""
  echo "$HELP"
  echo ""
}
info() { printf "%s[INFO]%s %s\n" "$BLUE" "$RESET" "$*"; }
warn() { printf "%s[WARN]%s %s\n" "$YELLOW" "$RESET" "$*"; }
error() {
  printf "%s[ERROR]%s %s\n" "$RED" "$RESET" "$*"
  exit 1
}
ok() { printf "%s[SUCCESS]%s %s\n" "$GREEN" "$RESET" "$*"; }

run() {
  if (($DRY)); then
    echo "DRYRUN: $*"
  else
    if (($PROMPT)); then
      ring_bell
      echo "::RUN:: $@   ???"
      wait_for_user
      eval "$@"
    else
      eval "$@"
    fi
  fi
}

getc() {
  local save_state
  save_state="$(/bin/stty -g)"
  /bin/stty raw -echo
  IFS='' read -r -n 1 -d '' "$@"
  /bin/stty "${save_state}"
}

ring_bell() {
  # Use the shell's audible bell.
  if [[ -t 1 ]]; then
    printf "\a"
  fi
}

wait_for_user() {
  local c
  warn "Press RETURN/ENTER to continue or any other key to abort:"
  getc c
  # we test for \r and \n because some stuff does \r instead
  if ! [[ "${c}" == $'\r' || "${c}" == $'\n' ]]; then
    exit 1
  fi
}

# ---------------------- Repo -----------------
hide() {
  gh repo edit --visibility private --accept-visibility-change-consequences
}

unhide() {
  gh repo edit --visibility public --accept-visibility-change-consequences

}

bump_version() {
  DATE=$(date "+%Y-%m-%d_%H_%M_%S")

  # Need it public so the homebrew github update-formula can run
  gh repo edit --visibility public --accept-visibility-change-consequences
  git fetch origin main --tags
  git rebase origin/main

  # echo "$DATE" >VERSION

  SED="$(command -v gsed || command -v sed)"
  "$SED" -i.bak -e "s/^  version \".*\"$/  version \"${DATE}\"/" Formula/denver.rb
  rm -f Formula/denver.rb.bak

  git add Formula/denver.rb

  # Optional: avoid failing when nothing changed
  if git diff --cached --quiet; then
    echo "No changes to commit."
    exit 0
  fi

  git commit -m "Bump version to ${DATE}"

  # Do NOT force tags. Fail if tag already exists.
  git tag "${DATE}"

  # Push branch (force-with-lease is fine because you rebased)
  git push --force-with-lease origin main

  # Push the new tag (no force)
  git push origin "${DATE}"
}

update_brewfile() {
  brew bundle dump --describe --force --taps --brews --casks
  brew bundle remove danshumaker/denver
  brew bundle remove danshumaker/denver/denver
}

print_version() {
  if [[ -e Formula/denver.rb ]]; then
    # In repo dir so can check the formula
    info "Repo Formula Version"
    grep "version" Formula/denver.rb
    info "Repo Tag Version"
    git tag --list --sort=creatordate | tail -1
  else
    info "Not in Repo directory"
  fi
  payload

  info "Installed Version"
  grep -qx "version" Formula/denver.rb
  brew info denver

}

case "$OS" in
  Darwin) PLATFORM="macos" ;;
  Linux) PLATFORM="linux" ;;
  *) error "Unsupported OS: $OS" ;;
esac
info "Platform: $PLATFORM"

# ---------------------- Asset Management Functions ----------
xcode() {
  if [[ "$PLATFORM" == "macos" ]]; then
    if ! xcode-select -p >/dev/null 2>&1; then
      if (($UNINSTALL)); then
        ok "Xcode is not installed"
      else
        info "Installing Xcode Command Line Tools"
        run "xcode-select --install"
      fi
    else
      if (($UNINSTALL)); then
        run "sudo rm -rf /Library/Developer/CommandLineTools"
        ok "Xcode Command Line tools removed"
      else
        info "Xcode Command Line Tools are already installed."
      fi
    fi
  fi
}

# ----------------- Change Zsh to Bash default shell -------
shell() {
  info "Auditing shell configuration..."

  if [[ -z "${SHELL:-}" ]]; then
    error "\$SHELL is not set."
  fi

  if [[ ! -x "$SHELL" ]]; then
    error "\$SHELL points to a non-executable: $SHELL"
  fi

  if (($UNINSTALL)); then
    chsh -s "/bin/zsh"
  else
    if ! grep -qx "$SHELL" /etc/shells; then
      warn "\$SHELL ($SHELL) is not listed in /etc/shells"
    fi

    if command -v brew >/dev/null 2>&1; then

      info "Enforcing Homebrew bash as login shell..."

      BREW_BASH="$(brew --prefix)/bin/bash"

      if ! grep -qx "$BREW_BASH" /etc/shells; then
        info "Registering Homebrew bash in /etc/shells"
        echo "$BREW_BASH" | sudo tee -a /etc/shells >/dev/null
      fi

      if [[ "$SHELL" != "$BREW_BASH" ]]; then
        info "Changing login shell to $BREW_BASH"
        chsh -s "$BREW_BASH"
        ok "Login shell updated. Log out/in required."
      else
        ok "Homebrew bash already set as login shell"
      fi
    fi
  fi

}

# ---------------- Homebrew --------------
homebrew() {
  if ! command -v brew >/dev/null 2>&1; then
    if (($UNINSTALL)); then
      ok "Homebrew is not installed"
    else
      info "Installing Homebrew..."
      run '/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"'
    fi
  else
    if (($UNINSTALL)); then
      info "Uninstalling Homebrew"
      run '/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)"'
      exit 0
    else
      info "Homebrew already installed."
    fi
  fi

  # Load brew shellenv
  BREW_PREFIX="$(brew --prefix)"
  run 'eval "$(${BREW_PREFIX}/bin/brew shellenv)"'
}

payload() {
  command -v brew >/dev/null 2>&1 || error "Homebrew not installed."
  # ---------------- Verify Installation Success ----------------
  DENVER_PREFIX="$(brew --prefix denver || true)"
  PAYLOAD_DIR="$DENVER_PREFIX/share/denver"
  BREWFILE=$PAYLOAD_DIR/Brewfile
  DOTS=$PAYLOAD_DIR/dotfiles
  BACKUP_DIR="$HOME/.old_dots/backup_$(date +%Y%m%d_%H%M%S)"

  if [[ ! -d "$DENVER_PREFIX" ]]; then
    error "Denver prefix not found at: $DENVER_PREFIX"
  fi

  if [[ ! -d "$PAYLOAD_DIR" ]]; then
    error "Denver payload directory missing: $PAYLOAD_DIR"
  fi

  info "Denver payload detected at: $PAYLOAD_DIR"

  # ---------------- Verify Brewfile Exists ----------------

  if [[ ! -f "$BREWFILE" ]]; then
    error "Brewfile missing at: $BREWFILE"
  fi

}

# ---------------- Tap + Install formula ----------
denver() {
  if brew list --formula denver >/dev/null 2>&1; then
    if (($UNINSTALL)); then
      brew uninstall --zap --force denver 2>/dev/null || brew uninstall --force denver
      rm -rf "$(brew --cellar)/denver"
      rm -f "$(brew --prefix)/opt/denver"
      brew cleanup -s denver || true
      rm -f "$(brew --cache)"/denver--* 2>/dev/null || true
    else
      ok "Denver Installed"
    fi
  else
    if (($UNINSTALL)); then
      ok "denver is NOT installed"
    else
      run "brew tap danshumaker/denver"
      run "brew install denver"
      payload
    fi
  fi
}

# ---------------- Brew bundle --------------------
bundle() {
  if (($UNINSTALL)); then
    info "Uninstalling Homebrew formulas from Denver Brewfile..."
    payload

    if [[ -f "$BREWFILE" ]]; then
      brew bundle list --file "$BREWFILE" --formula |
        xargs brew uninstall --ignore-dependencies || true

      brew bundle list --file "$BREWFILE" --cask |
        xargs brew uninstall --cask --force || true

      brew autoremove
      brew cleanup --prune=all
    else
      error "Denver Brewfile not found"
    fi
  else
    logfile="/tmp/brew-bundle.log"
    info "Running brew bundle using ${BREWFILE}…"
    set +e # we will handle errors manually
    brew bundle --upgrade --file="${BREWFILE}" 2>&1 | tee "${logfile}"
    status=${PIPESTATUS[0]}
    set -e
    if [[ $status -ne 0 ]]; then
      error "brew bundle failed (exit code ${status}). See ${logfile}"
    fi
    ok "Brew bundle finished successfully"
  fi

}

# ---------------- Dotfile backup and Linking -------
dotfiles() {
  payload
  if (($UNINSTALL)); then
    if command -v rcdn >/dev/null 2>&1; then
      info "Removing Dotfile RCM symlinks..."
      cd "$HOME"
      run "rcdn -v -d \"$DOTS\""
    else
      warn "rcdn not found — cannot remove rcup symlinks."
    fi
    if [[ -d "$HOME/.old_dots" ]]; then
      LAST_BACKUP="$(ls -1dt "$HOME/.old_dots"/* 2>/dev/null | head -1)"
      if [[ -d "$LAST_BACKUP" ]]; then
        info "Restoring backup from $LAST_BACKUP"
        run "cp -v -R \"$LAST_BACKUP/.\" \"$HOME/\""
      else
        warn "No backups found inside ~/.old_dots"
      fi
    else
      warn "~/.old_dots does not exist; no backups to restore."
    fi
  else
    # ---------------- Backup dotfiles ----------------
    run "mkdir -p \"$BACKUP_DIR\""

    info "Backing up existing dotfiles... to $BACKUP_DIR"

    files=$(find "$DOTS" -type f -depth 1)
    for f in ${files[@]}; do
      rootFName=$HOME/.$(basename $f)
      if [[ -e "$rootFName" ]]; then
        if [[ -L "$rootFName" ]]; then
          # If it's a link then do NOT back it up but remove it so new links can be made
          run "rm -v \"$rootFName\""
        else
          run "mv -v \"$rootFName\" \"$BACKUP_DIR/\""
        fi
      fi
    done

    info "Running rcup..."
    cd $HOME
    run "ln -s \"$DOTS\"/rcrc $HOME/.rcrc"
    run "rcup -v -d \"$DOTS\""
    if [[ ! -L $HOME/.bash_profile ]]; then
      error "RCM up did not link dotfiles."
    else
      ok "Dotfiles installed"
      lsrc -d "$DOTS"
    fi
  fi
}

# ---------------- Rust --------------------
rust() {
  if ! command -v cargo >/dev/null 2>&1; then
    if (($UNINSTALL)); then
      info "Rust/Cargo Uninstalled"
    else
      info "Installing Rust/Cargo toolchain..."
      run 'curl --proto "=https" --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y'
    fi
  else
    if (($UNINSTALL)); then
      if command -v rustup >/dev/null 2>&1; then
        info "Removing Rust toolchain..."
        run "rustup self uninstall -y"
      fi
    else
      info "Rust already installed."
    fi
  fi
}

unhide
while [[ $# -gt 0 ]]; do
  case "$1" in
    -p | --prompt)
      PROMPT=1
      shift
      ;;
    -d | --dry-run)
      DRY=1
      shift
      ;;
    -v)
      shift
      set -v
      set -x
      ;;
    -u | --uninstall)
      UNINSTALL=1
      shift
      ;;
    -h | --help)
      # Function call
      help
      exit
      ;;
    --xcode)
      xcode
      exit
      ;;
    --brew | --homebrew)
      homebrew
      exit
      ;;
    --denver)
      denver
      exit
      ;;
    --bundle)
      bundle
      exit
      ;;
    --shell)
      shell
      exit
      ;;
    --rust)
      rust
      exit
      ;;
    --dots | --dotfiles)
      dotfiles
      exit
      ;;
    --priv | --private)
      hide
      exit
      ;;
    --pub | --public)
      unhide
      exit
      ;;
    --bump)
      bump_version
      exit
      ;;
    --ub)
      update_brewfile
      exit
      ;;
    --version)
      print_version
      exit
      ;;
    *)
      warn "Invalid Option ${argv[j]}"
      help
      exit
      ;;
  esac
done

if (($UNINSTALL)); then
  rust
  shell
  dotfiles
  hide
  bundle
  denver
  homebrew
  xcode
else
  # INSTALL DEFAULT
  xcode
  homebrew
  denver
  bundle
  dotfiles
  shell
  rust
  ok "Denver installation complete."
  hide
fi
